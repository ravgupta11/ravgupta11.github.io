<!doctype html>
<html lang="en">
  <head>
  	<title>Graph</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,800,900" rel="stylesheet">
		
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
		<link rel="stylesheet" href="css/style.css">
  <style type="text/css">
  .boxfont {
	font-family: "MS Serif", "New York", serif;
	font-size: 18px;
}
  </style>
  <script>
        MathJax = {
            tex: {
                inlineMath: [
                    ["$", "$"],
                    ["\\(", "\\)"]
                ]
            },
            svg: {
                fontCache: "global"
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </head>
  <body>
		
		<div class="wrapper d-flex align-items-stretch ">
			<nav id="sidebar">
				<div class="p-4 pt-1 sticky-top" style="overflow-y: auto; height: 600px;">
		  		<a href="#" class="img logo rounded-circle mb-1" style="background-image: url(images/logo.JPG);"></a>
	        <ul class="list-unstyled components mb-5">
	          <li class="active">
	            <a href="#homeSubmenu"  data-toggle="collapse" aria-expanded="true" class="dropdown-toggle collapsed">
                <i class="fa fa-link mr-2"></i> Graph</a>
	            <ul class="collapse show list-unstyled" id="homeSubmenu">
                <li>
                    <a href="#"><i class="fa fa-circle small mr-1"></i> Basics</a>
                </li>
                <li>
                    <a href="#represent"><i class="fa fa-circle small mr-1"></i> Representations</a>
                </li>
                <li>
                    <a href="#cycle"><i class="fa fa-circle small mr-1"></i> What is a cycle ? </a>
                </li>
                 <li>
                    <a href="#path"><i class="fa fa-circle small mr-1"></i> What is a path ? </a>
                </li>
                 <li>
                    <a href="#connectivity"><i class="fa fa-circle small mr-1"></i> Connectivity </a>
                </li>
                 <li>
                    <a href="#dfs"><i class="fa fa-circle small mr-1"></i> Depth First Search </a>
                </li>
                 <li>
                    <a href="#cycledet"><i class="fa fa-circle small mr-1"></i> Cycle Detection </a>
                </li>
                 <li>
                    <a href="#pathtree"><i class="fa fa-circle small mr-1"></i> Path tree</a>
                </li>
                <li>
                    <a href="#directed"><i class="fa fa-circle small mr-1"></i> Cycles in directed graphs</a>
                </li>
                <li>
                    <a href="#shortest"><i class="fa fa-circle small mr-1"></i> Shortest path problem</a>
                </li>
                <li>
                    <a href="#optimization"><i class="fa fa-circle small mr-1"></i> Optimization by BFS</a>
                </li>
                <li>
                    <a href="#proof"><i class="fa fa-circle small mr-1"></i> Proof of correctness</a>
                </li>
                <li>
                    <a href="#complexity1"><i class="fa fa-circle small mr-1"></i> complexity</a>
                </li>
                
	            </ul>
              
	          </li>
          <li><a href="geometry.html"><i class="fa fa-link mr-2"></i> Geometry</a> </li>
          <li>
            <a href="dp.html"><i class="fa fa-link mr-2"></i> DP</a> </li>
             <li>
            <a href="math.html"><i class="fa fa-link mr-2"></i> Math</a> </li>
          <li>
            <a href="greedy.html"><i class="fa fa-link mr-2"></i> Greedy</a> </li>
          <li>
            <a href="probability.html"><i class="fa fa-link mr-2"></i> Probability</a> </li>
          <li>
            <a href="searching.html"><i class="fa fa-link mr-2"></i> Searching</a> </li>
          <li>
            <a href="numberTheory.html"><i class="fa fa-link mr-2"></i> Number Theory</a> </li>
          <li>
            <a href="sorting.html"><i class="fa fa-link mr-2"></i> Sorting & Sets</a> </li>
          <li>
            <a href="../index.html"><i class="fa fa-link mr-2"></i> About me</a>  </li>
          <li>
	        </ul>
          
	        
	      </div>
    	</nav>

        <!-- Page Content  -->
      <div id="content" class="p-4 p-md-5">

        <nav class="navbar navbar-expand-lg navbar-light bg-light">
          <div class="container-fluid">

            <button type="button" id="sidebarCollapse" class="btn btn-primary">
              <i class="fa fa-bars"></i>
              <span class="sr-only">Toggle Menu</span>
            </button>
            <button class="btn btn-dark d-inline-block d-lg-none ml-auto" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                <i class="fa fa-bars"></i>
            </button>

            <div class="collapse navbar-collapse" id="navbarSupportedContent">
              <ul class="nav navbar-nav ml-auto">
                <!-- <li class="nav-item active">
                    <a class="nav-link" href="#">Home</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">About</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">Portfolio</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">Contact</a>
                </li> -->
              </ul>
            </div>
          </div>
        </nav>

        <div class="leftcolumn">
          <h2 class="titles">Basics</h2>
            
                    <p class="bordertxt">
                        Graph is a generic structure designed to support relationships. and is defined as a set of
                        vertices $1, 2, .. n$ often labeled and edges usually written as $(vertex_1, vertex_2)$
                    </p>

                 
                
                    <p class="bordertxt">
                        $E$ is set of edges and $V$ is set of nodes. 2 vertices are adjacent if there is an edge a
                        between those 2 vertices.
                    </p>

                
                
                    <p class="bordertxt">
                        Normally we denote $|V| = n$ and $|E| = m$ where $|V|$ is cardinality (number of elements)
                        of a set.
                    </p>
          <div class="picdiv">
                <div class="IMG"><img src="images/graphex.png" width="200" height="200" /></div><br>

                <div class="IMG"><img src="images/matrix.png" /></div>
            </div>
          <h2 class="titles">Representation<a name="represent"></a></h2>
                    <p class="bordertxt">
                        $E$ is set of edges and $V$ is set of nodes. 2 vertices are adjacent if there is an edge a between those 2 vertices. of a set.
                    </p>
                    <p class="bordertxt">
                        List of all edges i.e $(1, 2), (3, 4), ...$ but its not very convenient to work with. 
                    </p>
                    <p class="bordertxt">
                        The second way to represent the graph is the adjacent matrix. Its the simplest way to represent the matrix. Its an $n \times n$ matrix where $e_{ij} = 1$ iff there exist an edge between $i$ and $j$. 
                    </p>
                    <p class="bordertxt">
                        There is an important observation in this matrix that diagonal elements are 0 which means there is no edge from a node to itself i.e self loop. 
                    </p>
                        <p class="bordertxt">
                        Another common and important way to represent a graph is called an Adjacency List. For each vertix we write down list of vertices that are incident on that vertix. 
                    </p>
                    
                    
                    
                    
                 <h2 class="titles">C++: Implementation</h2>
            
                    <p class="bordertxt">
                        Initializing the structures for un-weighted case.
                    </p>

                 
                
<div class="code boxfont">
                            <div
                                style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                                <pre style="margin: 0; line-height: 125%"><span style="color: #557799">#include&lt;vector&gt; </span><span style="color: #888888">//We use stl:vector to make lists.</span>
<span style="color: #557799">#include &lt;utility&gt;</span>
<span style="color: #008800; font-weight: bold">using</span> <span style="color: #008800; font-weight: bold">namespace</span> std; 
<span style="color: #333399; font-weight: bold">int</span> n, m; <span style="color: #888888">// number of nodes and edges</span>
<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">int</span> MAXN <span style="color: #333333">=</span> <span style="color: #6600EE; font-weight: bold">1e5</span> <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">5</span>; <span style="color: #888888">//  maximum number of vertices possible</span>
<span style="color: #888888">//Initializing the structures</span>
vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> G[MAXN]; <span style="color: #888888">// an array of vectors (lists)</span>
vector<span style="color: #333333">&lt;</span> pair<span style="color: #333333">&lt;</span> <span style="color: #333399; font-weight: bold">int</span>, <span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">&gt;</span> <span style="color: #333333">&gt;</span> E; <span style="color: #888888">// list of pair of values</span>
<span style="color: #333399; font-weight: bold">bool</span> adj[MAXN][MAXN]; <span style="color: #888888">// a matrix of MAXN x MAXN initialized to 0</span>
</pre>
                            </div>
                        </div><br>

                        <p class="bordertxt">
                            Initializing the structures for weighted case.
                        </p>
                        
                        <div class="bordertxt">
                            <div
                                style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                                <pre style="margin: 0; line-height: 125%"><span style="color: #557799">#include&lt;vector&gt;</span>
<span style="color: #557799">#include &lt;utility&gt;</span>
<span style="color: #557799">#define ll long long</span>
<span style="color: #008800; font-weight: bold">using</span> <span style="color: #008800; font-weight: bold">namespace</span> std; 
<span style="color: #333399; font-weight: bold">int</span> n, m; <span style="color: #888888">// number of nodes and edges</span>
<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">int</span> MAXN <span style="color: #333333">=</span> <span style="color: #6600EE; font-weight: bold">1e5</span> <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">5</span>; <span style="color: #888888">//  maximum number of vertices possible</span>
<span style="color: #888888">//Initializing the structures</span>
vector<span style="color: #333333">&lt;</span>pair<span style="color: #333333">&lt;</span> <span style="color: #333399; font-weight: bold">int</span>, ll <span style="color: #333333">&gt;</span> <span style="color: #333333">&gt;</span> G[MAXN]; <span style="color: #888888">// an array of vectors (lists)</span>
vector<span style="color: #333333">&lt;</span> pair <span style="color: #333333">&lt;</span> pair<span style="color: #333333">&lt;</span> <span style="color: #333399; font-weight: bold">int</span>, <span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">&gt;</span>, ll<span style="color: #333333">&gt;</span> <span style="color: #333333">&gt;</span> E; <span style="color: #888888">// list of pair of values</span>
ll adj[MAXN][MAXN]; <span style="color: #888888">// a matrix of MAXN x MAXN initialized to 0</span>
</pre>
                            </div>
                        </div><br>
<p class="bordertxt">
                            Inserting edges to the structures for weighted and un-directed case.
                        </p>
                        <div class="bordertxt">
                            <div
                                style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                                <pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> m; i<span style="color: #333333">++</span>){ 
    <span style="color: #333399; font-weight: bold">int</span> u, v;ll w;
    scanf(<span style="background-color: #fff0f0">&quot;%d %d %lld&quot;</span>, <span style="color: #333333">&amp;</span>u, <span style="color: #333333">&amp;</span>v, <span style="color: #333333">&amp;</span>w);
    u<span style="color: #333333">--</span>; v<span style="color: #333333">--</span>; <span style="color: #888888">// if starting label of the input is 1 decrease it to make it 0.</span>
    G[u].push_back({v, w});
    G[v].push_back({u, w});
    adj[u][v] <span style="color: #333333">=</span> w;
    adj[v][u] <span style="color: #333333">=</span> w;
    E.push_back({{u, v}, w});
}
</pre>
                            </div>
                        </div><br>

                        
                        <h2 >
                    What is a Cycle ?
                <a name="cycle"></a></h2>
                <div class="picdiv">
                    <img src="images/cycle.png" width="200" height="200" />
                </div>
                 <p class="bordertxt">
                            A cycle is a sequence of vertices $v_1, v_2, v_3, ... v_k$ where each $(v_i, v_{i+1})$ is
                            adjacent and $v_1$ is adjacent to $v_k$.
                        </p>
<p class="bordertxt">
                            A cycle is simple if all vertices on it are distinct.
                        </p>
                        
          <div class="leftcolumn">
                <h2 class="titles">What is a Path ? Path Search Problem<a name="path"></a></h2>
            <div class="picdiv">
                    <img src="images/path.png" width="200" />
                </div>
            <p class="bordertxt">
                            A path is a sequence of vertices $v_1, v_2, v_3, ... v_k$ where each $(v_i, v_{i+1})$ is
                            adjacent.
                        </p>
                   
                        <p class="bordertxt">
                            A path is simple if all vertices are distinct.
                        </p>
                   
                        <p class="bordertxt">
                            Given a graph $G$ and 2 vertices $s$ and $t$. Check if a path from $s$ to $t$ exists ? If it
                            exists print the path.
                        </p>
                  
                        <p class="bordertxt">
                            Think about it as exploring a labyrinth (maze).
                        </p>
                    
            </div>
                        
       <div class="leftcolumn">
                <h2 >
                    What is connectivity ?
                <a name="connectivity"></a></h2>
                <div class="rightcolumn">
                <div class="picdiv">
                    <img src="images/connected.png" width="200" height="200" />
                </div>
         </div>
                
                        <p class="bordertxt" >
                            Two nodes are connected if there exist a path between them. If I can go from one node to
                            another using the edges of the graph.
                        </p>
                   
                        <p class="bordertxt">
                            Connected components is a set of vertices where each of 2 vertices are connected and no
                            other vertice outside the component is connected .
                        
                       </p>
                  <div class="picdiv"><img src="images/dfs4img.png" width="269" height="1059" /></div>

            </div>                 
                    
          <div class="leftcolumn">
                <h2 >
                    Algorithms: DFS (Depth First Search)
                <a name="dfs"></a></h2>
                  <div class="rightcolumn">
                <div class="picdiv"></div><br>

            </div>  
               
            <p class="bordertxt">
                            Now lets try to find all the vertices that are connected to some vertice 1.
                        </p>
                   
                        <p class="bordertxt">
                            For ex: Imagine you are trapped in some labyrinth and you want to find out the exit door.
                            You are in some room and don't know where the exit is.
                        </p>
                   
                     <p class="bordertxt">
                         You try first door out of that room. You go to next room and try the first door out of that
                            room. If once you come to a room you already been to you wont enter that room and go back.
                     You try the second door out of the old room and traverse the labyrinth. </p>
                 
                     <p class="bordertxt">
                         There are two types of basic traverses DFS and BFS. They both differ in the order of
                         vertices visited but both of the searches traverses the graph.
                     </p>
                  
                        <p class="bordertxt">
                            In DFS we go through the first door of the first room and then again go through the first
                            door of he second room and similarly we go deeper and deeper till we finally encounter the
                            place we already been. Lets try to formalize it.
                        </p>
                    
                        <p class="bordertxt">
                            Black colored directed edges forms a path tree / DFS tree
                        </p>
                   
            </div> <br>
<br>
<br><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

          
                        
       <div class="leftcolumn">
                <h2 >Pseudo Code:</h2>
                <div class="picdiv"><img src="images/psu3img.png" width="325" height="1358" /></div>
                
         <div class="code class="bordertxt"" >
                    <div 
                        style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                        <pre style="margin: 0; line-height: 125%">recursive pseudo code
visit(_fro)<span style="color: #333333">:</span>
    mark _fro visited
    <span style="color: #008800; font-weight: bold">for</span> all _to adjacent to _fro<span style="color: #333333">:</span>
        <span style="color: #008800; font-weight: bold">if</span> _to is not visited<span style="color: #333333">:</span>
            visit(_to)

iterative pseudo code
visit(src)<span style="color: #333333">:</span>
    initialize stack with src
    stack <span style="color: #333333">:=</span> {src}
    <span style="color: #008800; font-weight: bold">while</span> stack is not empty<span style="color: #333333">:</span>
        _fro <span style="color: #333333">:=</span> stack.pop()
        <span style="color: #008800; font-weight: bold">if</span> _fro is not visited<span style="color: #333333">:</span>
            mark _fro visited
            <span style="color: #008800; font-weight: bold">for</span> all _to adjacent to _fro<span style="color: #333333">:</span>
                push _to to stack
                
</pre>
                    </div>
                </div>
            </div><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
                
                     
          <div class="leftcolumn">
                <h2 >
                    C++ Implementation
                </h2>
                <div class="code">
                    <div
                        style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                        <pre style="margin: 0; line-height: 125%">recursive definition
<span style="color: #333399; font-weight: bold">bool</span> vis[MAXN];
<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i<span style="color: #333333">++</span>) vis[i] <span style="color: #333333">=</span> <span style="color: #007020">false</span>;

<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i<span style="color: #333333">++</span>) <span style="color: #008800; font-weight: bold">if</span>(<span style="color: #333333">!</span>vis[i]) dfs(i);

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">dfs</span>(<span style="color: #333399; font-weight: bold">int</span> fro){
    vis[fro] <span style="color: #333333">=</span> <span style="color: #007020">true</span>;
    <span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> to<span style="color: #333333">:</span> G[fro]){
        <span style="color: #008800; font-weight: bold">if</span>(vis[to]) <span style="color: #008800; font-weight: bold">continue</span>;
        dfs(to);
    }
}

iterative approach
<span style="color: #333399; font-weight: bold">bool</span> vis[MAXN];
<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i<span style="color: #333333">++</span>) vis[i] <span style="color: #333333">=</span> <span style="color: #007020">false</span>;

<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i<span style="color: #333333">++</span>) <span style="color: #008800; font-weight: bold">if</span>(<span style="color: #333333">!</span>vis[i]) dfs(i);

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">dfs</span>(<span style="color: #333399; font-weight: bold">int</span> src){
    vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> stack;
    stack.push_back(src);
    <span style="color: #008800; font-weight: bold">while</span>( <span style="color: #333333">!</span>stack.empty() ){
        <span style="color: #333399; font-weight: bold">int</span> fro <span style="color: #333333">=</span> stack.pop_back();
        <span style="color: #008800; font-weight: bold">if</span>(vis[fro]) <span style="color: #008800; font-weight: bold">continue</span>;
        vis[fro] <span style="color: #333333">=</span> <span style="color: #007020">true</span>;
        <span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> to<span style="color: #333333">:</span> G[fro]) stack.push_back(to);
    }
}
</pre>
                    </div>
                </div>
            </div>  <br>
 
            <br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<div class="leftcolumn">
                <h2 >
                    What is the complexity of this algorithm ?
                </h2>
                <div class="picdiv"><img src="images/coa3img.png" width="297" height="2646" /></div>
               
                        <p class="bordertxt">
                            It depends upon how we represent the graph. If we store thegraph as a adjacency matrix its
                            $O(n^2)$. If its stored in adjacency list its $O(n+m)$. Why?
                        </p>
                    
                        <p class="bordertxt">
                            We visit each vertix only once because the in recursive procedure dfs is only called for
                            vertices which is not yet visited and when its called vis[] of the vertice is set true and
                            for each vertice the visit mark is set true only once.
                        </p>
                   
                        <p class="bordertxt">
                            If we store the graph in the adjacency matrix , we have to traverse through all the matrix
                            and find the vertices that are adjacent tofro. For each vertice it takes $O(n)$ to find its
                            adjacent vertices and in total $O(n^2)$ for all vertices.
                        </p>
                  
                        <p class="bordertxt">
                            If we store the graph in adjacency list its $O(n+m)$, and for eachvertice, we can find the
                            adjacent vertice in $O(1)$. and for eachvertice we can touch each adjacent node from it
                            exactly once.and for each vertice we can use each edge going from it exactly
                            once. So if all vertices and edges are touched once so its $O(n+m)$.
                        </p>
                    </div><br>
<br>
<br>
<br>
<br><br>



           
          <div class="leftcolumn">
                <h2 >
                    Pseudo Code: DFS with colors and time
                </h2>

                <div class="code">
                    <script src="https://gist.github.com/ravgupta11/2a74b377e79027449f10528be00bfce7.js"></script>
                </div>
            </div>
            <div class="leftcolumn">
                <h2 >
                    Properties of Times
                </h2>

               
                        <p class="bordertxt">
                            For any u and v time segments [tin[u], tout[u]] and [tin[v], tout[v]].
                        </p>
                   
                        <p class="bordertxt">
                            if[tin[u], tout[u]]is nested in[tin[v], tout[v]]means thatuis a de-scendant ofvandvis a
                            ancestor ofuin the DFS / PATH tree.
                        </p>
                   
                        <p class="bordertxt">
                            if[tin[u], tout[u]]and[tin[v], tout[v]]do not intersect - meaning uand v are not comparable.
                        </p>
                    
            </div>
            
            <div class="leftcolumn">
                <h2 >
                    Type Of Edges:
                </h2>
                
                        <p class="bordertxt">
                            These classifications are often used for problems like finding bridges and finding
                            articulation points.
                        </p>
                    
                        <p class="bordertxt">
                            Tree Edges : Edges going from GRAY to WHITE vertex in the DFS tree.
                        </p>
                    
                        <p class="bordertxt">
                            Backward Edges : Edges going from GRAY to GRAY vertex in the DFS tree.
                        </p>
                    
                        <p class="bordertxt">
                            Forward Edges (ONLY IN DIRECTED GRAPH) : Edges goingfrom GRAY to BLACK vertex in the DFS
                            tree. If v is a descen-dant of u, then edge (u,v) is a forward edge. In other words, ifwe
                            already visited and exited v and entry[u] entry[v] then theedge (u,v) forms
                            a forward edge.
                        </p>
                   
                        <p class="bordertxt">
                            Cross Edges (ONLY IN DIRECTED GRAPH): Edges goingfrom GRAY to BLACK vertex in the DFS tree.
                            if v is nei-ther an ancestor or descendant of u, then edge (u,v) is a crossedge. In other
                            words, if we already visited and exited v and entry[u] entry[v] then
                            (u,v) is a cross edge.
                        </p>
                    
                        <p class="bordertxt">
                            Look on the times tin / tout to choose forward or cross.
                        </p>
                   
            </div>
            
           <br>
<br>
<br>

          <div id="cycledet" class="leftcolumn">
                <h2 >
                    Cycle Detection: Application of DFS
                </h2>
               <div class="picdiv"><img src="images/cd1.png" width="217" height="190" /></div>
               
                        <p class="bordertxt">
                            Cycle exists if and only if a backward edge exists, i.e look up from the vertex to a GRAY
                            vertex (careful with un-directed graph skip the edge from which you came to the current)
                        </p>
                   
                        <p class="bordertxt">
                            Why can’t we go from go from a current vertex to a black vertex? Because when we mark the
                            vertex a as black we processed all its edges that out go this vertex and we should have
                            processed all adjacent vertex B that’s the reason we can’t reach a black
                            vertex from the current node and whenever we find a cycle its always an edge from current
                            node to a gray node.
                        </p>
                   
                        <p class="bordertxt">
                            Make sure you distinguish between a cycle and going back to the parent. A separate par in
                            the dfs definition i.e visit(fro, par) because you need to remember where you came from.
                        </p>
                   
            </div>
            
            <div id="pathtree" class="leftcolumn">
                <h2 >
                    Path Tree
                </h2>
               
                        <p class="bordertxt">
                            Path Tree is an outgoing tree routed at s. Path tree covers all vertices reachable from s.
                        </p>
                    
                        <p class="bordertxt">
                            parent[u] = u for root vertex u = src
                        </p>
                   
                        <p class="bordertxt">
                            parent[u] = −1 for unreachable vertices u
                        </p>
                   
                        <p class="bordertxt">
                            parent[u] = v if v is the previous vertex for u on the path from from s to u.
                        </p>
                  
                        <p class="bordertxt">
                            pseudo code to restore path
                        </p>
                    
                        <p class="bordertxt">
                            Beware of the identifier prev as there exist a std:prev predefined in C++. If you code in
                            other languages then just don’t care.
                        </p>
                    
                <div class="code class="bordertxt"">
                    <div
                        style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                        <pre style="margin: 0; line-height: 125%">function pathTo(t):
    path :<span style="color: #333333">=</span> []
    <span style="color: #008800; font-weight: bold">while</span> parent[t] <span style="color: #333333">!=</span> t: <span style="color: #333333">//</span>t <span style="color: #000000; font-weight: bold">is</span> <span style="color: #000000; font-weight: bold">not</span> root
        push t to path structure
        t :<span style="color: #333333">=</span> parent[t] <span style="color: #333333">//</span> go towards root
    push t to path <span style="color: #333333">//</span> t <span style="color: #000000; font-weight: bold">is</span> root
    reverse(path) 
    <span style="color: #008800; font-weight: bold">return</span> path
</pre>
                    </div>
                </div>
            </div><br>

            
            <div class="leftcolumn">
                <h2 class="titles">
                    Directed case
                <a name="directed"></a></h2>
               
         <div class="picdiv"><img src="images/dc1.png" width="301" height="624" /></div>               
         <p class="bordertxt">
                            Adjacency matrix is not symmetric in this case.
                        </p>
                   
                        <p class="bordertxt">
                            There can be directed relationships, like if person A can be a friend of person B but not
                            true the other way around.
                        </p>
                   
                        <p class="bordertxt">
                            There can be similar problems like if $u$ is reachable from vertex $v$.
                        </p>
                   
                        <p class="bordertxt">
                            We can extract connected components from the directed graph. They are called Strongly
                            connected components.
                        </p>
                   
                        <p class="bordertxt">
                            Let's try finding a cycle in a directed case. From 1 to 2 and 2 to 3 marks 3 visited and 2
                            visited and goes 1 to 3 and finds 3 visited and says its a cycle. but there was'nt.
                        </p>
                   
                        <p class="bordertxt">
                            Lets try explicitly state colors with 3 values. 0 means WHITE not yet visited, 1 means gray
                            means visited but not processed, 2 means BLACK means visited an processed.
                        </p>
                   
                        <p class="bordertxt">
                            A cycle only exists only if we go from current node to a gray node.
                        </p>
                    
            </div>
            
            <div class="leftcolumn">
                <h2 >
                    Shortest Path Problem: Directed or un-directed graph
                <a name="shortest"></a></h2>
            <div class="picdiv"><img src="images/sp1.png" width="283" height="690" /></div>     
              <p class="bordertxt">
                            Given a graph G find the shortest path between a pair of vertices $s$ and $t$.
                        </p>
                   
                        <p class="bordertxt">
                            All the edges in my graph is same length.
                        </p>
                    
                        <p class="bordertxt">
                            Lets discuss a simpler but an inefficient algorithm to solve this problem called Flood Fill
                        </p>
                   
                        <p class="bordertxt">
                            We say the best distance from s to s is 0.
                        </p>
                   
                        <p class="bordertxt">
                            Next step is that we consider all adjacent vertices of $s$. and decide that the distance to
                            them is 1. This is so called the first layer.
                        </p>
                   
                        <p class="bordertxt">
                            Now I want to enumerate all those vertices with distance 1 and assign them distance one more
                            than my current distance. There might be some problem that some vertices at level 2 might be
                            adjacent to several vertices from the level 1. TO keep things simple
                            I will just need to assign those vertices which are yet unassigned.
                        </p>
                  
                        <p class="bordertxt">
                            Eventually this way we will cover all the vertices of the connected component that has the
                            vertex $s$.
                        </p>
                  
                        <p class="bordertxt">
                            There are efficient algorithms that does exactly the same thing but a bit faster.
                        </p>
                    
                        <p class="bordertxt">
                            When we have several layers to the bottom and we meet some vertex with length 3 and is
                            connected to some vertex length 1. we would like to assign length 4 to it but this situation
                            will never happen. Why ?
                        </p>
                   
                        <p class="bordertxt">
                            Since we are enumerating vertices in increasing order of the layers, so the vertex with
                            length 3 would actually have assigned a length of 2 since it was connected with a vertex of
                            length 1.
                        </p>
                    
            </div>
            
            <div class="leftcolumn">
                <h2 >
                    Optimization by Queue
                <a name="optimization"></a></h2>
              
              <p class="bordertxt">
                            Lets understand how to find those levels efficiently. We will use a data structure called a
                            queue. Queue uses FIFO strategy, which is first in and first out. It behaves like a normal
                            queue in front of a ticket booth.
                        </p>
                    
                        <p class="bordertxt">
                            I have to maintain the queue with initial entry $s$ and I have to maintain a distances[]
                            array to store the distance from $s$. Assume all vertices except $s$ has a very big distance
                            $10^9 + 7$ and s having distance 0.
                        </p>
                                           <p class="bordertxt">
                            First thing to do is, to extract a vertex from the queue and we process it. what do we do in
                            processing? To process the vertex I look through all the outgoing edges of this vertex and I
                            try to relax the big distance( $10^9 + 7$) from s to its neighbours
                            to something smaller.
                    
                        <p class="bordertxt">
                            In our case from $s$ we can go to $a$ , $b$ , $c$ in 1 step, so I update their distance to 1
                            and push all the updated vertices to the queue. Now the vertex $s$ is processed.
                        </p>
                   
                        <p class="bordertxt">
                            The next step is to extract the next vertex from the queue and repeat the same procedure and
                            try to relax (make smaller ) those distances which are larger than current + 1.
                        </p>
                   
                        <p class="bordertxt">
                            Eventually all the vertices in the connected component is assigned.
                        </p>
                   
            </div><br>

             
          <div class="leftcolumn">
                <h2 >
                    What is the proof of correctness ?
                <a name="proof"></a></h2>
             <div class="picdiv"><img src="images/poc1.png" width="283" height="690" /></div>     
            <p class="bordertxt">
                            Why does it works ?
                        </p>
                   
                        <p class="bordertxt">
                            There are 2 observations.
                        </p>
                    
                        <p class="bordertxt">
                            All vertices will eventually in the queue
                        </p>
                   
                        <p class="bordertxt">
                            All vertices will be in the queue exactly once
                        </p>
                   
                        <p class="bordertxt">
                            There cannot be a situation where we relax a vertex and put it in the queue and relax it
                            twice and put it in the queue again.
                        </p>
                  
                        <p class="bordertxt">
                            Lets say a vertex $x$ whose has an edge to a vertex $v$ which has some distance $5$ and $x$
                            has distance $6$ and there also exist a vertex $u$ which already has a distance say $3$ and
                            also want to relax (make better) distance for $x$ and relax it to 4.
                        </p>
                    
                        <p class="bordertxt">
                            Why cannot this situation happen ?
                        </p>
                    
                        <p class="bordertxt">
                            Because $u$ will be processed first than $v$ as we are processing in increasing order of
                            levels/ layers/ distances. That proves the correctness
                        </p>
                        
                    
            <div id="complexity" class="card">
                <!-- Repeated element on each chapter-->
                <div class="leftcolumn">
                    <h2 class="titles">
                        What is the complexity of this algorithm ?
                    <a name="complexity1"></a></h2>
                    
                            <p class="bordertxt">
                                Running time in $O(n + m)$ if we use adjacency list and its $O(n^2 + m)$ if we use
                                adjacency matrices since we push all vertices will be in the queue exactly once .
                            </p>
                       
                    <div class="code">
                        <script src="https://gist.github.com/ravgupta11/ac0111e43f2e81a56e4e2e0cda1c6564.js"></script>
                    </div>
                </div>
            </div>
    </div> 
    </div> 
    </div>   

    <script src="js/jquery.min.js"></script>
    <script src="js/popper.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/main.js"></script>
  </body>
</html>
