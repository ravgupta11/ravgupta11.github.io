<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>The blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="style.css" />
    <script>
        MathJax = {
            tex: {
                inlineMath: [
                    ["$", "$"],
                    ["\\(", "\\)"]
                ]
            },
            svg: {
                fontCache: "global"
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body>
    <header>
        <div id="inner">
            <div id="profile_pic"></div>
            <h1 class="site-title">Raveesh Gupta</h1>
            <p class="site-description">A blog on sport programming</p>
        </div>
    </header>
    <div id="content-wrapper">
        <div id="nav">
            <ul>
                <li><a href="#basics">Graph</a></li>
                <li><a>Geometry</a></li>
                <li><a>DP</a></li>
                <li><a>Math</a></li>
                <li><a>Greedy</a></li>
                <li><a>Probability</a></li>
                <li><a>Number Theory</a></li>
            </ul>
        </div>
        <div id="basics" class="card">
            <div class="leftcolumn">
                <h2 class="titles">Basics</h2>
                <div class="IMG"><img src="Images/xkcd1.png" /></div>
                <ul>
                    <li>
                        <p>
                            Graph is a generic structure designed to support relationships. and is defined as a set of vertices $1, 2, .. n$ often labeled and edges usually written as $(vertex_1, vertex_2)$
                        </p>
                    </li>
                    <li>
                        <p>
                            $E$ is set of edges and $V$ is set of nodes. 2 vertices are adjacent if there is an edge a between those 2 vertices.
                        </p>
                    </li>
                    <li>
                        <p>
                            Normally we denote $|V| = n$ and $|E| = m$ where $|V|$ is cardinality (number of elements) of a set.
                        </p>
                    </li>
                </ul>
            </div>
            <div class="rightcolumn">
                <ul>
                    <li><a href="#basics">BASICS</a></li>
                    <li><a>DFS</a></li>
                    <li><a>APPL: DFS</a></li>
                    <li><a>BFS</a></li>
                    <li><a>APPL: BFS</a></li>
                    <li><a>DAG</a></li>
                    <li><a>DIJKSTRA</a></li>
                </ul>
            </div>
        </div>
        <div id="represent" class="card">
            <div class="leftcolumn">
                <h2 class="titles">Representation</h2>
                <ul>
                    <li>
                        <p>
                            In algorithmic problems we use 3 ways to represent the graph.
                        </p>
                    </li>
                    <li>
                        <p>
                            Edge List, Adjacency List, Adjacency Matrix is the 3 common ways to represent ways to represent the graph.
                        </p>
                    </li>
                    <li>
                        <p>
                            List of all edges i.e $(1, 2), (3, 4), ...$ but its not very convenient to work with.
                        </p>
                    </li>
                    <li>
                        <p>
                            The second way to represent the graph is the adjacent matrix. Its the simplest way to represent the matrix. Its an $n \times n$ matrix where $e_{ij} = 1$ iff there exist an edge between $i$ and $j$.
                        </p>
                    </li>
                    <li>
                        <p>
                            There is an important observation in this matrix that diagonal elements are 0 which means there is no edge from a node to itself i.e self loop.
                        </p>
                    </li>
                    <li>
                        <p>
                            Another common and important way to represent a graph is called an Adjacency List. For each vertix we write down list of vertices that are incident on that vertix.
                        </p>
                    </li>
                </ul>
            </div>
            <div class="rightcolumn">
                <div class="IMG"><img src="Images/graphex.png" /></div>
                <div class="IMG"><img src="Images/matrix.png" /></div>
            </div>
        </div>
        <div class="card">
            <div class="leftcolumn" style="width: 100%;">
                <h2 class="titles">C++: Implementation</h2>
                <ul>
                    <li>
                        <p>
                            Initializing the structures for un-weighted case.
                        </p>
                        <div class="code">
                            <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                                <pre style="margin: 0; line-height: 125%"><span style="color: #557799">#include&lt;vector&gt; </span><span style="color: #888888">//We use stl:vector to make lists.</span>
<span style="color: #557799">#include &lt;utility&gt;</span>
<span style="color: #008800; font-weight: bold">using</span> <span style="color: #008800; font-weight: bold">namespace</span> std; 
<span style="color: #333399; font-weight: bold">int</span> n, m; <span style="color: #888888">// number of nodes and edges</span>
<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">int</span> MAXN <span style="color: #333333">=</span> <span style="color: #6600EE; font-weight: bold">1e5</span> <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">5</span>; <span style="color: #888888">//  maximum number of vertices possible</span>
<span style="color: #888888">//Initializing the structures</span>
vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> G[MAXN]; <span style="color: #888888">// an array of vectors (lists)</span>
vector<span style="color: #333333">&lt;</span> pair<span style="color: #333333">&lt;</span> <span style="color: #333399; font-weight: bold">int</span>, <span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">&gt;</span> <span style="color: #333333">&gt;</span> E; <span style="color: #888888">// list of pair of values</span>
<span style="color: #333399; font-weight: bold">bool</span> adj[MAXN][MAXN]; <span style="color: #888888">// a matrix of MAXN x MAXN initialized to 0</span>
</pre>
                            </div>
                        </div>
                    </li>
                    <li>
                        <p>
                            Inserting edges to the structures for un-weighted and un-directed case.
                        </p>
                        <div class="code">
                            <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                                <pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> m; i<span style="color: #333333">++</span>){ 
                <span style="color: #333399; font-weight: bold">int</span> u, v;
                scanf(<span style="background-color: #fff0f0">&quot;%d %d&quot;</span>, <span style="color: #333333">&amp;</span>u, <span style="color: #333333">&amp;</span>v);
                u<span style="color: #333333">--</span>; v<span style="color: #333333">--</span>; <span style="color: #888888">// if starting label of the input is 1 decrease it to make it 0.</span>
                G[u].push_back(v);
                G[v].push_back(u);
                adj[u][v] <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span>;
                adj[v][u] <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span>;
                E.push_back({u, v});
            }
</pre>
                            </div>
                        </div>
                    </li>
                    <li>
                        <p>
                            Initializing the structures for weighted case.
                        </p>
                        <div>
                            <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                                <pre style="margin: 0; line-height: 125%"><span style="color: #557799">#include&lt;vector&gt;</span>
<span style="color: #557799">#include &lt;utility&gt;</span>
<span style="color: #557799">#define ll long long</span>
<span style="color: #008800; font-weight: bold">using</span> <span style="color: #008800; font-weight: bold">namespace</span> std; 
<span style="color: #333399; font-weight: bold">int</span> n, m; <span style="color: #888888">// number of nodes and edges</span>
<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">int</span> MAXN <span style="color: #333333">=</span> <span style="color: #6600EE; font-weight: bold">1e5</span> <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">5</span>; <span style="color: #888888">//  maximum number of vertices possible</span>
<span style="color: #888888">//Initializing the structures</span>
vector<span style="color: #333333">&lt;</span>pair<span style="color: #333333">&lt;</span> <span style="color: #333399; font-weight: bold">int</span>, ll <span style="color: #333333">&gt;</span> <span style="color: #333333">&gt;</span> G[MAXN]; <span style="color: #888888">// an array of vectors (lists)</span>
vector<span style="color: #333333">&lt;</span> pair <span style="color: #333333">&lt;</span> pair<span style="color: #333333">&lt;</span> <span style="color: #333399; font-weight: bold">int</span>, <span style="color: #333399; font-weight: bold">int</span> <span style="color: #333333">&gt;</span>, ll<span style="color: #333333">&gt;</span> <span style="color: #333333">&gt;</span> E; <span style="color: #888888">// list of pair of values</span>
ll adj[MAXN][MAXN]; <span style="color: #888888">// a matrix of MAXN x MAXN initialized to 0</span>
</pre>
                            </div>
                        </div>
                    </li>
                    <li>
                        <p>
                            Inserting edges to the structures for weighted and un-directed case.
                        </p>
                        <div>
                            <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                                <pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> m; i<span style="color: #333333">++</span>){ 
    <span style="color: #333399; font-weight: bold">int</span> u, v;ll w;
    scanf(<span style="background-color: #fff0f0">&quot;%d %d %lld&quot;</span>, <span style="color: #333333">&amp;</span>u, <span style="color: #333333">&amp;</span>v, <span style="color: #333333">&amp;</span>w);
    u<span style="color: #333333">--</span>; v<span style="color: #333333">--</span>; <span style="color: #888888">// if starting label of the input is 1 decrease it to make it 0.</span>
    G[u].push_back({v, w});
    G[v].push_back({u, w});
    adj[u][v] <span style="color: #333333">=</span> w;
    adj[v][u] <span style="color: #333333">=</span> w;
    E.push_back({{u, v}, w});
}
</pre>
                            </div>
                        </div>
                    </li>
                </ul>
            </div>
        </div>
        <div class="card">
            <div class="leftcolumn">
                <h2 class="titles">
                    What is a Cycle ?
                </h2>
                <ul>
                    <li>
                        <p>
                            A cycle is a sequence of vertices $v_1, v_2, v_3, ... v_k$ where each $(v_i, v_{i+1})$ is adjacent and $v_1$ is adjacent to $v_k$.
                        </p>
                    </li>
                    <li>
                        <p>
                            A cycle is simple if all vertices on it are distinct.
                        </p>
                    </li>
                </ul>
            </div>
            <div class="rightcolumn">
                <div class="IMG">
                    <img src="Images/cycle.png" />
                </div>
            </div>
        </div>
        <div class="card">
            <div class="leftcolumn">
                <h2 class="titles">What is a Path ? Path Search Problem</h2>
                <ul>
                    <li>
                        <p>
                            A path is a sequence of vertices $v_1, v_2, v_3, ... v_k$ where each $(v_i, v_{i+1})$ is adjacent.
                        </p>
                    </li>
                    <li>
                        <p>
                            A path is simple if all vertices are distinct.
                        </p>
                    </li>
                    <li>
                        <p>
                            Given a graph $G$ and 2 vertices $s$ and $t$. Check if a path from $s$ to $t$ exists ? If it exists print the path.
                        </p>
                    </li>
                    <li>
                        <p>
                            Think about it as exploring a labyrinth (maze).
                        </p>
                    </li>
                </ul>
            </div>
            <div class="rightcolumn">
                <div class="IMG">
                    <img src="Images/path.png" />
                </div>
            </div>
        </div>
        <div class="card">
            <div class="leftcolumn">
                <h2 class="titles">
                    What is connectivity ?
                </h2>
                <ul>
                    <li>
                        <p>
                            Two nodes are connected if there exist a path between them. If I can go from one node to another using the edges of the graph.
                        </p>
                    </li>
                    <li>
                        <p>
                            Connected components is a set of vertices where each of 2 vertices are connected and no other vertice outside the component is connected .
                        </p>
                    </li>
                </ul>
                <div class="IMG"><img src="Images/xkcd2.png" /></div>
            </div>

            <div class="rightcolumn">
                <div class="IMG">
                    <img src="Images/connected.png" />
                </div>
            </div>
        </div>
        <div class="card">
            <div class="rightcolumn">
                <div class="IMG">
                    <img src="Images/dfs1.png" />
                </div>
                <div class="IMG">
                    <img src="Images/dfs2.png" />
                </div>
                <div class="IMG">
                    <img src="Images/dfs3.png" />
                </div>
                <div class="IMG">
                    <img src="Images/dfs4.png" />
                </div>
                <div class="IMG">
                    <img src="Images/dfs5.png" />
                </div>
                <div class="IMG">
                    <img src="Images/dfs6.png" />
                </div>
                <div class="IMG">
                    <img src="Images/dfs7.png" />
                </div>
                <div class="IMG">
                    <img src="Images/dfs8.png" />
                </div>
                <div class="IMG">
                    <img src="Images/dfs9.png" />
                </div>
            </div>
            <div class="leftcolumn">
                <h2 class="titles">
                    Algorithms: DFS (Depth First Search)
                </h2>
                <ul>
                    <li>
                        <p>
                            Now lets try to find all the vertices that are connected to some vertice 1.
                        </p>
                    </li>
                    <li>
                        <p>
                            For ex: Imagine you are trapped in some labyrinth and you want to find out the exit door. You are in some room and don't know where the exit is.
                        </p>
                    </li>
                    <li>
                        <p>
                            You try first door out of that room. You go to next room and try the first door out of that room. If once you come to a room you already been to you wont enter that room and go back. You try the second door out of the old room and traverse the labyrinth.
                        </p>
                    </li>
                    <li>
                        <p>
                            There are two types of basic traverses DFS and BFS. They both differ in the order of vertices visited but both of the searches traverses the graph.
                        </p>
                    </li>
                    <li>
                        <p>
                            In DFS we go through the first door of the first room and then again go through the first door of he second room and similarly we go deeper and deeper till we finally encounter the place we already been. Lets try to formalize it.
                        </p>
                    </li>
                    <li>
                        <p>
                            Black colored directed edges forms a path tree / DFS tree
                        </p>
                    </li>
                </ul>
            </div>
            <div class="leftcolumn">
                <h2 class="titles">Pseudo Code:</h2>
                <div class="code">
                    <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                        <pre style="margin: 0; line-height: 125%">recursive pseudo code
visit(_fro)<span style="color: #333333">:</span>
    mark _fro visited
    <span style="color: #008800; font-weight: bold">for</span> all _to adjacent to _fro<span style="color: #333333">:</span>
        <span style="color: #008800; font-weight: bold">if</span> _to is not visited<span style="color: #333333">:</span>
            visit(_to)

iterative pseudo code
visit(src)<span style="color: #333333">:</span>
    initialize stack with src
    stack <span style="color: #333333">:=</span> {src}
    <span style="color: #008800; font-weight: bold">while</span> stack is not empty<span style="color: #333333">:</span>
        _fro <span style="color: #333333">:=</span> stack.pop()
        <span style="color: #008800; font-weight: bold">if</span> _fro is not visited<span style="color: #333333">:</span>
            mark _fro visited
            <span style="color: #008800; font-weight: bold">for</span> all _to adjacent to _fro<span style="color: #333333">:</span>
                push _to to stack
                
</pre>
                    </div>
                </div>
            </div>

            <div class="leftcolumn">
                <h2 class="titles">
                    C++ Implementation
                </h2>
                <div class="code">
                    <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                        <pre style="margin: 0; line-height: 125%">recursive definition
<span style="color: #333399; font-weight: bold">bool</span> vis[MAXN];
<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i<span style="color: #333333">++</span>) vis[i] <span style="color: #333333">=</span> <span style="color: #007020">false</span>;

<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i<span style="color: #333333">++</span>) <span style="color: #008800; font-weight: bold">if</span>(<span style="color: #333333">!</span>vis[i]) dfs(i);

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">dfs</span>(<span style="color: #333399; font-weight: bold">int</span> fro){
    vis[fro] <span style="color: #333333">=</span> <span style="color: #007020">true</span>;
    <span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> to<span style="color: #333333">:</span> G[fro]){
        <span style="color: #008800; font-weight: bold">if</span>(vis[to]) <span style="color: #008800; font-weight: bold">continue</span>;
        dfs(to);
    }
}

iterative approach
<span style="color: #333399; font-weight: bold">bool</span> vis[MAXN];
<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i<span style="color: #333333">++</span>) vis[i] <span style="color: #333333">=</span> <span style="color: #007020">false</span>;

<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i<span style="color: #333333">++</span>) <span style="color: #008800; font-weight: bold">if</span>(<span style="color: #333333">!</span>vis[i]) dfs(i);

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">dfs</span>(<span style="color: #333399; font-weight: bold">int</span> src){
    vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> stack;
    stack.push_back(src);
    <span style="color: #008800; font-weight: bold">while</span>( <span style="color: #333333">!</span>stack.empty() ){
        <span style="color: #333399; font-weight: bold">int</span> fro <span style="color: #333333">=</span> stack.pop_back();
        <span style="color: #008800; font-weight: bold">if</span>(vis[fro]) <span style="color: #008800; font-weight: bold">continue</span>;
        vis[fro] <span style="color: #333333">=</span> <span style="color: #007020">true</span>;
        <span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> to<span style="color: #333333">:</span> G[fro]) stack.push_back(to);
    }
}
</pre>
                    </div>
                </div>
            </div>
            <div class="leftcolumn">
                <h2 class="titles">
                    What is the complexity of this algorithm
                </h2>
                <ul>
                    <li>
                        <p>
                            It depends upon how we represent the graph. If we store thegraph as a adjacency matrix its $O(n^2)$. If its stored in adjacency list its $O(n+m)$. Why?
                        </p>
                    </li>
                    <li>
                        <p>
                            We visit each vertix only once because the in recursive procedure dfs is only called for vertices which is not yet visited and when its called vis[] of the vertice is set true and for each vertice the visit mark is set true only once.
                        </p>
                    </li>
                    <li>
                        <p>
                            If we store the graph in the adjacency matrix , we have to traverse through all the matrix and find the vertices that are adjacent tofro. For each vertice it takes $O(n)$ to find its adjacent vertices and in total $O(n^2)$ for all vertices.
                        </p>
                    </li>
                    <li>
                        <p>
                            If we store the graph in adjacency list its $O(n+m)$, and for eachvertice, we can find the adjacent vertice in $O(1)$. and for eachvertice we can touch each adjacent node from it exactly once.and for each vertice we can use each edge going from it exactly
                            once. So if all vertices and edges are touched once so its $O(n+m)$.
                        </p>
                    </li>
                </ul>
            </div>
            <div class="leftcolumn">
                <h2 class="titles">
                    Pseudo Code: DFS with colors and time
                </h2>
                <div class="code">
                    <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                        <pre style="margin: 0; line-height: 125%">function dfs(u, p):
        parent[u] :<span style="color: #333333">=</span> p
        color[u] :<span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span>
        tin[u] :<span style="color: #333333">=</span> T<span style="color: #333333">++</span>
        <span style="color: #008800; font-weight: bold">for</span> each v, v adjacent to u:
            <span style="color: #008800; font-weight: bold">if</span> color[v] <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">0</span> :
                dfs(v, u)
        color[u] :<span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">2</span>
        tout[u] :<span style="color: #333333">=</span> T<span style="color: #333333">++</span>
    main:
        parent[] :<span style="color: #333333">=</span> <span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>
        parent[s] :<span style="color: #333333">=</span> s <span style="color: #333333">//</span> arbitrary source
        color[] :<span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>
        <span style="color: #008800; font-weight: bold">for</span> each i vertex:
            <span style="color: #008800; font-weight: bold">if</span> color[i] <span style="color: #333333">!=</span> <span style="color: #0000DD; font-weight: bold">2</span> :
                dfs(i,i)
</pre>
                    </div>
                </div>
            </div>

            <div class="leftcolumn">
                <h2 class="titles">
                    Properties of Times
                </h2>

                <ul>
                    <li>
                        <p>
                            For any u and v time segments [tin[u], tout[u]] and [tin[v], tout[v]].
                        </p>
                    </li>
                    <li>
                        <p>
                            if[tin[u], tout[u]]is nested in[tin[v], tout[v]]means thatuis a de-scendant ofvandvis a ancestor ofuin the DFS / PATH tree.
                        </p>
                    </li>
                    <li>
                        <p>
                            if[tin[u], tout[u]]and[tin[v], tout[v]]do not intersect - meaning uand v are not comparable.
                        </p>
                    </li>
                </ul>
            </div>
            <div class="rightcolumn">
                <div class="IMG"><img src="Images/time1.png" /> </div>
                <div class="IMG"></div><img src="Images/time2.png" /></div>
            <div class="IMG"></div><img src="Images/time3.png" /></div>
        <div class="IMG"></div><img src="Images/time5.png" /></div>
    <div class="IMG"></div><img src="Images/time4.png" /></div>
    <div class="IMG"></div><img src="Images/time6.png" /></div>
    <div class="IMG"></div><img src="Images/time7.png" /></div>
    <div class="IMG"></div><img src="Images/time8.png" /></div>
    <div class="IMG"></div><img src="Images/times9.png" /></div>
    </div>>
    <div class="leftcolumn">
        <h2 class="titles">
            Type Of Edges:
        </h2>
        <ul>
            <li>
                <p>
                    These classifications are often used for problems like finding bridges and finding articulation points.
                </p>
            </li>
            <li>
                <p>
                    Tree Edges : Edges going from GRAY to WHITE vertex in the DFS tree.
                </p>
            </li>
            <li>
                <p>
                    Backward Edges : Edges going from GRAY to GRAY vertex in the DFS tree.
                </p>
            </li>
            <li>
                <p>
                    Forward Edges (ONLY IN DIRECTED GRAPH) : Edges goingfrom GRAY to BLACK vertex in the DFS tree. If v is a descen-dant of u, then edge (u,v) is a forward edge. In other words, ifwe already visited and exited v and entry[u] entry[v] then theedge (u,v) forms
                    a forward edge.
                </p>
            </li>
            <li>
                <p>
                    Cross Edges (ONLY IN DIRECTED GRAPH): Edges goingfrom GRAY to BLACK vertex in the DFS tree. if v is nei-ther an ancestor or descendant of u, then edge (u,v) is a crossedge. In other words, if we already visited and exited v and entry[u] entry[v] then
                    (u,v) is a cross edge.
                </p>
            </li>
            <li>
                <p>
                    Look on the times tin / tout to choose forward or cross.
                </p>
            </li>
        </ul>
    </div>
    <div class="leftcolumn">
        <h2 class="titles">
            Cycle Detection: Application of DFS
        </h2>
        <ul>
            <li>
                <p>
                    Cycle exists if and only if a backward edge exists, i.e look up from the vertex to a GRAY vertex (careful with un-directed graph skip the edge from which you came to the current)
                </p>
            </li>
            <li>
                <p>
                    Why can’t we go from go from a current vertex to a black vertex? Because when we mark the vertex a as black we processed all its edges that out go this vertex and we should have processed all adjacent vertex B that’s the reason we can’t reach a black
                    vertex from the current node and whenever we find a cycle its always an edge from current node to a gray node.
                </p>
            </li>
            <li>
                <p>
                    Make sure you distinguish between a cycle and going back to the parent. A separate par in the dfs definition i.e visit(fro, par) because you need to remember where you came from.
                </p>
            </li>
        </ul>
    </div>
    <div class="rightcolumn">
        <div>
            <img src="Images/cycle2.png" />
        </div>
    </div>
    </div>
    <div class="leftcolumn">
        <h2 class="titles">
            Path Tree
        </h2>
        <ul>
            <li>
                <p>
                    Path Tree is an outgoing tree routed at s. Path tree covers all vertices reachable from s.
                </p>
            </li>
            <li>
                <p>
                    parent[u] = u for root vertex u = src
                </p>
            </li>
            <li>
                <p>
                    parent[u] = −1 for unreachable vertices u
                </p>
            </li>
            <li>
                <p>
                    parent[u] = v if v is the previous vertex for u on the path from from s to u.
                </p>
            </li>
            <li>
                <p>
                    pseudo code to restore path
                </p>
            </li>
            <li>
                <p>
                    Beware of the identifier prev as there exist a std:prev predefined in C++. If you code in other languages then just don’t care.
                </p>
            </li>
        </ul>
        <div class="code">
            <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                <pre style="margin: 0; line-height: 125%">function pathTo(t):
    path :<span style="color: #333333">=</span> []
    <span style="color: #008800; font-weight: bold">while</span> parent[t] <span style="color: #333333">!=</span> t: <span style="color: #333333">//</span>t <span style="color: #000000; font-weight: bold">is</span> <span style="color: #000000; font-weight: bold">not</span> root
        push t to path structure
        t :<span style="color: #333333">=</span> parent[t] <span style="color: #333333">//</span> go towards root
    push t to path <span style="color: #333333">//</span> t <span style="color: #000000; font-weight: bold">is</span> root
    reverse(path) 
    <span style="color: #008800; font-weight: bold">return</span> path
</pre>
            </div>
        </div>
    </div>
    </div>
    <div id="#directed" class="card">
        <!-- Repeated element on each chapter-->
        <div class="leftcolumn">
            <h2 class="titles">
                Directed case
            </h2>
            <ul>
                <li>
                    <p>
                        Adjacency matrix is not symmetric in this case.
                    </p>
                </li>
                <li>
                    <p>
                        There can be directed relationships, like if person A can be a friend of person B but not true the other way around.
                    </p>
                </li>
                <li>
                    <p>
                        There can be similar problems like if $u$ is reachable from vertex $v$.
                    </p>
                </li>
                <li>
                    <p>
                        We can extract connected components from the directed graph. They are called Strongly connected components.
                    </p>
                </li>
                <li>
                    <p>
                        Let's try finding a cycle in a directed case. From 1 to 2 and 2 to 3 marks 3 visited and 2 visited and goes 1 to 3 and finds 3 visited and says its a cycle. but there was'nt.
                    </p>
                </li>
                <li>
                    <p>
                        Lets try explicitly state colors with 3 values. 0 means WHITE not yet visited, 1 means gray means visited but not processed, 2 means BLACK means visited an processed.
                    </p>
                </li>
                <li>
                    <p>
                        A cycle only exists only if we go from current node to a gray node.
                    </p>
                </li>
            </ul>
        </div>
        <div class="rightcolumn">
            <div class="IMG"><img src="Images/cycle3.png" /></div>
        </div>
    </div>
    <div id="shortest" class="card">
        <!-- Repeated element on each chapter-->
        <div class="leftcolumn">
            <h2 class="titles">
                Shortest Path Problem: Directed or un-directed graph
            </h2>
            <ul>
                <li>
                    <p>
                        Given a graph G find the shortest path between a pair of vertices $s$ and $t$.
                    </p>
                </li>
                <li>
                    <p>
                        All the edges in my graph is same length.
                    </p>
                </li>
                <li>
                    <p>
                        Lets discuss a simpler but an inefficient algorithm to solve this problem called Flood Fill
                    </p>
                </li>
                <li>
                    <p>
                        We say the best distance from s to s is 0.
                    </p>
                </li>
                <li>
                    <p>
                        Next step is that we consider all adjacent vertices of $s$. and decide that the distance to them is 1. This is so called the first layer.
                    </p>
                </li>

                <li>
                    <p>
                        Now I want to enumerate all those vertices with distance 1 and assign them distance one more than my current distance. There might be some problem that some vertices at level 2 might be adjacent to several vertices from the level 1. TO keep things simple
                        I will just need to assign those vertices which are yet unassigned.
                    </p>
                </li>

                <li>
                    <p>
                        Eventually this way we will cover all the vertices of the connected component that has the vertex $s$.
                    </p>
                </li>
                <li>
                    <p>
                        There are efficient algorithms that does exactly the same thing but a bit faster.
                    </p>
                </li>
                <li>
                    <p>
                        When we have several layers to the bottom and we meet some vertex with length 3 and is connected to some vertex length 1. we would like to assign length 4 to it but this situation will never happen. Why ?
                    </p>
                </li>

                <li>
                    <p>
                        Since we are enumerating vertices in increasing order of the layers, so the vertex with length 3 would actually have assigned a length of 2 since it was connected with a vertex of length 1.
                    </p>
                </li>
            </ul>
        </div>
        <div class="rightcolumn">
            <div class="IMG"> <img src="Images/bfs0.png"></div>
            <div class="IMG"> <img src="Images/bfs1.png"> </div>
            <div class="IMG"> <img src="Images/bfs2.png"> </div>
        </div>
    </div>
    <div id="optimization" class="card">
        <!-- Repeated element on each chapter-->
        <div class="leftcolumn">
            <h2 class="titles">
                Optimization by Queue
            </h2>
            <ul>
                <li>
                    <p>
                        Lets understand how to find those levels efficiently. We will use a data structure called a queue. Queue uses FIFO strategy, which is first in and first out. It behaves like a normal queue in front of a ticket booth.
                    </p>
                </li>
                <li>
                    <p>
                        I have to maintain the queue with initial entry $s$ and I have to maintain a distances[] array to store the distance from $s$. Assume all vertices except $s$ has a very big distance $10^9 + 7$ and s having distance 0.
                    </p>
                </li>
                <li>
                    <p>
                        First thing to do is, to extract a vertex from the queue and we process it. what do we do in processing? To process the vertex I look through all the outgoing edges of this vertex and I try to relax the big distance( $10^9 + 7$) from s to its neighbours
                        to something smaller.
                </li>
                <li>
                    <p>
                        In our case from $s$ we can go to $a$ , $b$ , $c$ in 1 step, so I update their distance to 1 and push all the updated vertices to the queue. Now the vertex $s$ is processed.
                    </p>
                </li>
                <li>
                    <p>
                        The next step is to extract the next vertex from the queue and repeat the same procedure and try to relax (make smaller ) those distances which are larger than current + 1.
                    </p>
                </li>
                <li>
                    <p>
                        Eventually all the vertices in the connected component is assigned.
                    </p>
                </li>
            </ul>
        </div>
    </div>
    <div id="" class="card">
        <!-- Repeated element on each chapter-->
        <div class="leftcolumn">
            <h2 class="titles">
                What is the proof of correctness ?
            </h2>
            <ul>
                <li>
                    <p>
                        Why does it works ?
                    </p>
                </li>
                <li>
                    <p>
                        There are 2 observations.
                    </p>
                </li>
                <li>
                    <p>
                        All vertices will eventually in the queue
                    </p>
                </li>
                <li>
                    <p>
                        All vertices will be in the queue exactly once
                    </p>
                </li>
                <li>
                    <p>
                        There cannot be a situation where we relax a vertex and put it in the queue and relax it twice and put it in the queue again.
                    </p>
                </li>
                <li>
                    <p>
                        Lets say a vertex $x$ whose has an edge to a vertex $v$ which has some distance $5$ and $x$ has distance $6$ and there also exist a vertex $u$ which already has a distance say $3$ and also want to relax (make better) distance for $x$ and relax it to 4.
                    </p>
                </li>
                <li>
                    <p>
                        Why cannot this situation happen ?
                    </p>
                </li>
            </ul>
            <li>
                <p>
                    <div class="IMG">
                        <img src="Images/bfs3.png" />
                    </div>
                </p>
            </li>
            <li>
                <p>
                    Because $u$ will be processed first than $v$ as we are processing in increasing order of levels/ layers/ distances. That proves the correctness
                </p>
            </li>
        </div>
    </div>
    <div id="complexity" class="card">
        <!-- Repeated element on each chapter-->
        <div class="leftcolumn">
            <h2 class="titles">
                What is the complexity of this algorithm ?
            </h2>
            <ul>
                <li>
                    <p>
                        Running time in $O(n + m)$ if we use adjacency list and its $O(n^2 + m)$ if we use adjacency matrices since we push all vertices will be in the queue exactly once .
                    </p>
                </li>
            </ul>
            <div class="code">
                <script src="https://gist.github.com/ravgupta11/ac0111e43f2e81a56e4e2e0cda1c6564.js"></script>
            </div>
        </div>
    </div>
    </div>
</body>

</html>